---
title: "Validate single expansion"
author: "David Helekal"
date: "12/2/2020"
output:
  html_document:
    df_print: paged
---

```{r, eval mcmc}
eval_mcmc <- TRUE
```

```{bash, clean directory, include=FALSE, eval=eval_mcmc}
rm -rf ./Paper/Sim/sim_zero_exp
rm -rf ./Paper/Sim/tmp

mkdir tmp
```

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(CaveDive)
library(rmutil)
library(ape)
library(ggplot2)
library(ggtree)
library(ggExtra)
library(treeio)
library(viridis)
library(rjson)

dir.create(file.path("./Paper/Sim/", "sim_zero_exp"))
base_dir <- "./Paper/Sim/sim_zero_exp"
```
## Simulation Validation

This notebook simulates several different sets of genealogies containing a single expnasion and tests MCMC inference against them, aiming to validate how well are parameters recovered across different scales.

### Parameter Recovery

This section validates how well are model parameters recovered across different population size scales and different expansion rates

### Set up the experiment 
```{r, set parameters}
set.seed(1)

burn_in <- 0.1
n_it <- 2e6
thinning <- n_it/1e4

repetitions <- 100
dims <- 0
lambdar_range <- c(5)
pop_range <- c(4)
```

```{r, generate parameter specification files, eval=eval_mcmc}
dir.create(file.path(base_dir, "test_spec"))
dir.create(file.path(base_dir, "test_out"))

seed <- 0

for(j in c(1:length(pop_range))) {
  dir_name <- paste0("pop_",j)
  dir.create(file.path(paste0(base_dir,"/test_spec"), dir_name))
    dir.create(file.path(paste0(base_dir,"/test_out"), dir_name))
    for (l in c(1:repetitions)) {
      params <- c(paste0("-e ", dims),
                  paste0("-s ", seed),
                  paste0("-t ", runif(1,80,300)), 
                  paste0("-l ", 5),
                  paste0("--meanscale ", pop_range[j]),
                  paste0("--sdscale ", 1),
                  paste0("-o ",base_dir,"/test_out/",dir_name, "/r_",l),
                  paste0("--metadata ", paste0("\"","N_idx:",j,"\""))) 
      fname <- paste0("r_",l,".txt")
      fileConn<-file(paste0(base_dir,"/test_spec/", dir_name,"/", fname))
        writeLines(params, fileConn)
      close(fileConn)
      seed <- seed+1
  }
}
```

### Simulate the parameters of individual processes
```{bash, simulate parameters, results=FALSE, eval=eval_mcmc}
find ./sim_zero_exp | grep .*.txt | xargs -L 1 cat | parallel -j 20 --verbose --tmpdir ./tmp -n 8 --halt-on-error 2 eval Rscript "./Scripts/simulate_tree.R {}"
```

### Run MCMC inference 
```{bash, run mcmc, results=FALSE, eval=eval_mcmc}
find ./sim_zero_exp | grep .*tree.nwk | xargs dirname | parallel -j 20 --verbose --tmpdir ./tmp --halt-on-error 2 eval Rscript "./Scripts/run_expansions_inference_nwk.R -n 2e6 -t 2e2 --lambdar 1 -s 1 -f {}/tree.nwk -o {}"
```

### Produce plots for dimension mode analysis
```{r, process data}
experiment_specs <- list.files(path = paste0(base_dir,"/test_out"), pattern=".*tree_params.json", full.names = TRUE, recursive = TRUE)
experiment_dirs <- dirname(experiment_specs)

results_data <- lapply(c(1:length(experiment_specs)), function(i){
  sim_data <- fromJSON(file=experiment_specs[i])
  meta_data <- sim_data$meta
  sim_data <- lapply(sim_data, unlist) 
  sim_data <- lapply(sim_data, as.numeric) 

  dim.gt <- sim_data$n_exp
  t_mid.gt <- sim_data$t_mid
  K.gt <- sim_data$K
  N.gt <- sim_data$N
  time.gt <- sim_data$div_times
  br.gt <- sim_data$root_set
  time.gt <- time.gt[-length(time.gt)]  

  ### Check that we got the number of expansions approximately right 
  expansions <- readRDS(paste0(experiment_dirs[i],"/expansions.rds"))
  expansions <- discard_burn_in(expansions, proportion=burn_in)
  pre <- expansions$phylo_preprocessed

  mcmc_data <- expansions$model_data
  event_data <- expansions$expansion_data

  p_correct_dim <- length(which(mcmc_data$dim==dim.gt))/length(mcmc_data$dim)
  expected_dim <- mean(mcmc_data$dim)

  unique.dim <- unique(mcmc_data$dim)
  mode_dim <- unique.dim[which.max(sapply(unique.dim, function(x) length(which(mcmc_data$dim == x))))]

  ### take the one dimensional marginal
  correct_dim <- mcmc_data[which(mcmc_data$dim==dim.gt),]
  correct_dim_it <- correct_dim$it

  if(length(correct_dim_it) > 0) {
    exp_N <- mean(correct_dim$N)
  } else {
    exp_N <- NA
  }

  return(list(p_correct_dim=p_correct_dim, 
              expected_dim=expected_dim, 
              mode_dim=mode_dim,
              exp_N=exp_N,
              N_gt=N.gt))
})
```

```{r, create dataframe}
names(results_data) <- c(1:length(results_data)) 
data_df <- do.call(rbind.data.frame, results_data)
```

```{r, plot model probability, eval=T}
plt <- ggplot(data_df, aes(x=p_correct_dim))
plt <- plt + ggtitle("P Correct Model")
plt <- plt + geom_histogram(colour="darkgreen", fill="white", bins=40)
plt <- plt + theme_bw() + labs(x = "PRobability of Correct Model")
plt <- plt + theme(axis.text.x = element_text(angle = 45, hjust = 1))
plot(plt)
```

```{r, plot mode dim, eval=T}
plt <- ggplot(data_df, aes(x=mode_dim))
plt <- plt + ggtitle("Mode Dimension")
plt <- plt + geom_histogram(colour="darkgreen", fill="white", binwidth=1)
plt <- plt + theme_bw() + labs(x = "model index")
plt <- plt + theme(axis.text.x = element_text(angle = 45, hjust = 1))
plot(plt)
```


```{r, plot N err scatter, eval=T}
plt <- ggplot(data_df, aes(x=N_gt, y=exp_N))
plt <- plt + ggtitle("Inferred N versus true N")
plt <- plt + geom_point()
plt <- plt + theme_bw() + labs(x ="True N", y="Inferred N")
plt <- plt + geom_abline(intercept = 0, slope = 1)
plt <- plt + theme(axis.text.x = element_text(angle = 45, hjust = 1))
plot(plt)
```
### Done