---
title: "Cavedive 101"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Put the title of your vignette here}
  %\VignetteEngine{knitr::rmarkdown}
  \usepackage[utf8]{inputenc}
---

```{r, echo = FALSE, message = FALSE}
knitr::opts_chunk$set(collapse = T, comment = "#>")
options(tibble.print_min = 4, tibble.print_max = 4)
```

This vignette demonstrates the basic usage of the CaveDive package.

# Overview

1. Model setup and simulations. This section covers how to instatiate priors, and how different prior hyperparameters can be interpreted or elicited

2. Simulating genealogies with expansions, and their visualisation.

3. Inference under the CaveDive model, and displaying results

To begin, lets load `CaveDive` and `ape`. `CaveDive` uses `ape` as a backend to manipulate and store phylogenies.

```{r setup, message=FALSE} 
library(ape)
library(CaveDive)
set.seed(1)
```

## priorList
We parametrise and instatiate a _priorList_ object, which we will use to sample simulated genealogies with clonal expansions. The parameters we need to set are:

| prior parameters       | model parameter                    | Intepretation                                                                   |
|------------------------|------------------------------------|---------------------------------------------------------------------------------|
|`expansion_rate`        | $M$ (Number of Expansions)         | Poisson rate that governs the number of expansions in a population              |
|`N_mean_log`            | $N_M$ (Background Population Size) | Lognormal mean of prior distribution on background (neutral) population         |
|`N_sd_log`              | $N_M$ (Background Population Size) | Lognormal sd of prior distribution on background (neutral) population           |
|`t_mid_rate`            | $t_{mid_i}$ (Speed of Growth)      | Non-dimensional exponential rate of prior distribution on how long it takes for an expansion to reach half its maximum size|
|`K_sd_log`              | $K_i$ (Expansion Carrying Capacity)| Lognormal sd of prior distribution on the maximum population sizes at which individual expansions saturate.|
|`exp_time_nu`           | $t_{div_i}$ (Time of expansions)   | Parameter that controls the mean of the gamma prior on the time expansions      |
|`exp_time_kappa`        | $t_{div_i}$ (Time of expansions)   | Parameter that controls the variance of the gamma prior on the time expansions  |
|------------------------|------------------------------------|---------------------------------------------------------------------------------|

Note that the form of the priors on expansion carrying capacities is conditioned on $N_M$. $N_M$ thus acts as a form of a scale parameter for the entire genealogy, and governs what can be detected and what cannot. (For example, consider all samples within an expansion coalescing while the expansion population is near-saturated. Such an expansion will leave very little signature in the genealogy, potentially being indistinguishable from a mild bottleneck. Inference of the corresponding $t_mid$ parameter will be ouright impossible.)

The full exponential rate of prior on $t_{mid_i}$ is `t_mid_rate * N_M`.
The mean and the variance of the gamma prior on time of expansions is `exp_time_nu * N_M` and `exp_time_kappa^2 * N_M^2` respectively.


```{r parametrise priors, message=FALSE}
    expansion_rate<-1 
    N_mean_log<-4 
    N_sd_log<-1 
    t_mid_rate<-5
    K_sd_log<-1/2 
    exp_time_nu<-1/2
    exp_time_kappa<-1/4
```

```{r priors, message=FALSE} 
priors <- standard_priors(expansion_rate=expansion_rate, 
                            N_mean_log=N_mean_log, 
                            N_sd_log=N_sd_log, 
                            t_mid_rate=t_mid_rate, 
                            K_sd_log=K_sd_log, 
                            exp_time_nu=exp_time_nu, 
                            exp_time_kappa=exp_time_kappa)
print(priors)
```

Lets simulate a couple of genealogies with expansions in them, using `priors`. In order to do so we need to provide sampling times, i.e. the tip times of the simulated genealogy, as well as a concentration parameter for dirichlet prior on probabilities used to partition tips to individual expansions.
Note that all tips corresponding to an expansion must be sampled before the expansion diverges from it's parent. The simulation algorithm performs a fixed number of rejection sampling attempts to achieve this, and will error out if this number is exceeded. As such it is necessary to pick a reasonable sampling time scale.

CaveDive provides two sets of interfaces, a high level one, and a lower level one. In this vignette we cover the high level interface `simulate_expansion_phylo`.
This interface returns an `ape` phylogeny.
```{r set concentration, message=FALSE} 
concentration <- 2
```

The most basic use is as follows, with all parameters being sampled from priors. We pass 100 uniformly sampled tip times between 0 and -5. By setting `collapse_singles` to `TRUE` we ensure that the simulated genealogy will not contain nodes corresponding to events where an expansion diverges from a parent. 
Note: time of most recent tip must be 0.
```{r simulate a phylogeny, message=FALSE} 
tip_times <- runif(100, 0, 5)
tip_times <- tip_times - max(tip_times)
tip_times <- tip_times[order(-tip_times)]

phy1 <- simulate_expansion_phylo(priors, tip_times, concentration=concentration, collapse_singles=TRUE)
head(phy1)
```
One can also fix parameters used to simulate a phylogeny. For example, one might wish to generate a phylogeny with 3 expansions and background population size of 100.
```{r simulate a phylogeny 2, message=FALSE} 
tip_times <- runif(100, 0, 5)
tip_times <- tip_times - max(tip_times)
tip_times <- tip_times[order(-tip_times)]

phy2 <- simulate_expansion_phylo(priors, tip_times, concentration=concentration, given=list(n_exp=3, N=100), collapse_singles=TRUE)
```

Alternative one may wish to pre-assign the tips to individual expansions. A phylogeny with 2 expansions, where the first 30 tips belong to expansion number 1, the next 30 to expansion number 2, and 40 to the background population.
```{r simulate a phylogeny 3, message=FALSE} 
tip_times <- runif(100, 0, 5)
tip_times <- runif(100, 0, 5)
tip_times <- tip_times - max(tip_times)
tip_colours <- c(rep(1,30), rep(1,30), rep(1,40))

phy2 <- simulate_expansion_phylo(priors, tip_times, concentration=concentration, given=list(n_exp=2, tip_colours=tip_colours), collapse_singles=TRUE)
```

Plotting the three simulated phylogenies side by side. In order to colour the simulated phylogeny according to which part of the tree belongs to which expansion, we use `plot_structured_tree`. This function requires the number of expansions to colour as an argument. 

```{r,echo=FALSE, out.width='.33\\linewidth',fig.show='hold',fig.align='center'}
plot_structured_tree(phy1$tree, phy1$n_exp)
plot_structured_tree(phy2$tree, phy2$n_exp)
plot_structured_tree(phy3$tree, phy3$n_exp)
```